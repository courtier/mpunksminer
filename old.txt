fn encodePackedBytes(nonce: u256) [32]u8 {
    var buff: [32]u8 = undefined;
    var trunc_nonce: u88 = @truncate(u88, nonce);
    var last = last_mined;
    var addy = address;
    var i: usize = 11;
    while (i > 0) {
        buff[i] = @truncate(u8, last);
        last >>= 8;
        i -= 1;
    }
    buff[i] = @truncate(u8, last);
    i = 20;
    while (i > 12) {
        buff[i] = @truncate(u8, addy);
        addy >>= 8;
        i -= 1;
    }
    buff[i] = @truncate(u8, addy);
    i = 31;
    while (i > 21) {
        buff[i] = @truncate(u8, trunc_nonce);
        trunc_nonce >>= 8;
        i -= 1;
    }
    buff[i] = @truncate(u8, trunc_nonce);
    return buff;
}


fn bytesToInt(bytes: [32]u8) u256 {
    var res: u256 = 0;
    var power: u256 = 63;

    for (bytes) |c| {
        res += (c >> 4) * pow(16, power);
        power -= 1;
        res += (c & 15) * pow(16, power);
        if (power > 0)
            power -= 1;
    }
    return res;
}

fn pow(nt: u256, pt: u256) u256 {
    var res: u256 = 1;
    var p = pt;
    var n = nt;
    while (true) {
        if (p & 1 != 0)
            res *= n;
        p >>= 1;
        if (p == 0)
            break;
        n *= n;
    }
    return res;
}



fn isNonceValid(nonce: u256) bool {
    var pack = encodePackedBytes(nonce);
    var h: [Keccak_256.digest_length]u8 = undefined;
    Keccak_256.hash(pack[0..], &h, .{});
    log.info("{s}", .{fmt.fmtSliceHexLower(h[0..])});
    var n = @truncate(u88, bytesToInt(h));
    return n < difficulty_target;
}

fn miner(range_start: u256, range_end: u256) !void {
    var n = range_start;
    log.err("miner thread id: {d} - amount: {d}", .{ Thread.getCurrentId(), @truncate(u128, range_end - range_start) });
    while (n < range_end) {
        if (isNonceValid(n))
            try printBig(n);
        n += 1;
    }
}

fn printBig(n: u256) !void {
    var buf: [256]u8 = undefined;
    var mask = n;
    var i: u256 = 1 << 255;
    var c: usize = 0;
    while (i > 0) {
        if (mask & i > 0) buf[c] = '1' else buf[c] = '0';
        i /= 2;
        c += 1;
    }
    log.err("!!!FFFOUND NONCE: {s}", .{buf});
}

fn testconvert() void {
    var hex = "5d8bf379d4f4d0fc8c839549b49b75dba22487e8c7cae6a9f4db6bb8281f4fb5";
    var res: u256 = 0;
    var val: u256 = 0;
    var len: u256 = 63;
    for (hex) |c| {
        if (c >= '0' and c <= '9') {
            val = c - '0';
        } else {
            val = c - 'a' + 10;
        }
        res += val * pow(16, len);
        if (len > 0)
            len -= 1;
    }
    if (res == 42312367069190703812877940560644558352885497295098277674702133104701144518581) {
        std.log.info("good", .{});
    } else {
        std.log.warn("bad", .{});
    }
}
